using System.Collections.Generic;
using GeneticSharp.Domain.Chromosomes;

namespace GeneticSharp.Domain.Crossovers
{
    /// <summary>
    /// Defines a interface for a crossover genetic operator.
    /// <remarks>
    /// In genetic algorithms, crossover is a genetic operator used to vary the programming of a chromosome
    /// or chromosomes from one generation to the next. 
    /// <para>
    /// It is analogous to reproduction and biological crossover, upon which genetic algorithms are based. 
    /// Cross over is a process of taking more than one parent solutions and producing a child solution from them.
    /// </para>
    /// <see href="http://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)">Crossover (Genetic Algorithm)</see>
    /// </remarks>
    /// </summary>
    public interface ICrossover : IChromosomeOperator
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ICrossover"/> class.
        /// </summary>
        public ICrossover()
            : base(2, 2)
        {
            IsOrdered = false;
        }
        #endregion
        #region Properties
        /// <summary>
        /// Gets the number of parents need for cross.
        /// </summary>
        /// <value>The parents number.</value>
        int ParentsNumber { get; }

        /// <summary>
        /// Gets the number of children generated by cross.
        /// </summary>
        /// <value>The children number.</value>
        int ChildrenNumber { get; }

        /// <summary>
        /// Gets the minimum length of the chromosome supported by the crossover.
        /// </summary>
        /// <value>The minimum length of the chromosome.</value>
        int MinChromosomeLength { get; }
        #endregion

        #region Methods
        /// <summary>
        /// Cross the specified parents generating the children.
        /// </summary>
        /// <param name="parents">The parents chromosomes.</param>
        /// <returns>The offspring (children) of the parents.</returns>
        protected override IList<IChromosome> Cross(IList<IChromosome> parents)
        {
            var parent1 = parents[0];
            var parent2 = parents[1];

            int longitudParent1 = parent1.getLength();
            int longitudParent2 = parent2.getLength();


            var parent1Point = RandomizationProvider.Current.GetInt(0, 62) + 1;
            var random = RandomizationProvider.Current.GetInt(0, parent1.Length / 63);
            var parent2Point = parent1Point + 63 * random;
            var offspring2;
            if ((longitudParent1 == 63)&(longitudParent2 == 63))
            {
                offspring2 = parent1.CreateNew();
                offspring2.Resize(126);
                offspring2.ReplaceGenes(0, parent1.GetGenes().ToArray());
                offspring2.ReplaceGenes(63, parent2.GetGenes().ToArray());

            }
            else
            {
                offspring2 = CreateOffspring(parent2, parent1, parent2Point, parent1Point);
            }
            // The minium swap point is 1 to safe generate a gene with at least two genes.

            var offspring1 = CreateOffspring(parent1, parent2, parent1Point, parent2Point);
            

            return new List<IChromosome>() { offspring1, offspring2 };
        }

        private static IChromosome CreateOffspring(IChromosome leftParent, IChromosome rightParent, int leftParentPoint, int rightParentPoint)
        {
            var offspring = leftParent.CreateNew();

            offspring.Resize(leftParentPoint + (rightParent.Length - rightParentPoint));
            offspring.ReplaceGenes(0, leftParent.GetGenes().Take(leftParentPoint).ToArray());
            offspring.ReplaceGenes(leftParentPoint, rightParent.GetGenes().Skip(rightParentPoint).ToArray());

            return offspring;
        }
        #endregion
    }
}